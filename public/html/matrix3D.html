<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-touch-fullscreen" content="yes">
    <meta name="format-detection" content="telephone=no,email=no">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>transform</title>
    <link rel="stylesheet" href="../css/styles.css">
    <script id="vs" type="x-shader/x-vertex">
        attribute vec4 a_position;
        uniform mat4 u_matrix;
        void main(){
            gl_Position = u_matrix * a_position;
            //gl_Position = vec4( (u_matrix * vec3(a_position, 1)).xy, 0, 1);
        }
    </script>
    <script id="fs" type="x-shader/x-fragment">
        precision mediump float;
        uniform vec4 u_color;
        void main() {
           gl_FragColor = u_color;
        }
    </script>

</head>
<body>
<canvas id="canvas" width="500" height="400"></canvas>
<script src="../vendor/twgl.min.js"></script>
<!--matrix 列优先-->
<script src="../vendor/gl-matrix-min.js"></script>

<script>
    var canvas = document.getElementById('canvas');
    var gl = canvas.getContext('webgl');
    var program = twgl.createProgramFromScripts(gl, ['vs', 'fs']);
    gl.useProgram(program);

    // get location
    var positionLocation = gl.getAttribLocation(program, 'a_position');
    var matrixLocation = gl.getUniformLocation(program, 'u_matrix');
    var colorLocation = gl.getUniformLocation(program, 'u_color');

    // bind buffer & init value
    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
    setGeometry(gl);
    gl.uniform4f(colorLocation, Math.random(), Math.random(), Math.random(), 1);
    var Scene = {
        matrixOverlying: 1,
        anotherForm: 2,
        changeOrigin: 3,
        depth: 400 //深度
    };
    // draw
    drawScene(Scene.changeOrigin);

    function drawScene(type){
        gl.clear(gl.COLOR_BUFFER_BIT);
        // compute the matrix, 严格按顺序变换,对象是世界坐标系自身
        // I * S * S * T * S
        var projectionMatrix = mat4.fromValues(
                2/canvas.width, 0, 0, 0,
                0, -2/canvas.height, 0, 0,
                0, 0, 2/Scene.depth, 0,
                -1,  1,  0,  1
        );
        var translateMatrix = mat4.fromTranslation(mat4.create(), vec3.fromValues(100,100,20));
        var scaleMatrix = mat4.fromScaling(mat4.create(), vec3.fromValues(1, 1, 1));
        var rotateMatrix = mat4.fromRotation(mat4.create(), 20*Math.PI/180, vec3.fromValues(1,0.5,1));
        var matrix = mat4.create();
        if(type===Scene.matrixOverlying){
            // 执行顺序:R*S*T*P*I
            mat4.multiply(matrix, matrix, projectionMatrix);
            for(var ii=0;ii<5;ii++){
                mat4.multiply(matrix, matrix, translateMatrix);
                mat4.multiply(matrix, matrix, scaleMatrix);
                mat4.multiply(matrix, matrix, rotateMatrix);

                gl.uniformMatrix3fv(matrixLocation, false, matrix);
                gl.drawArrays(gl.TRIANGLES, 0, 18);
            }

            // same as:
            // I*R*S*T*P
            // mat4.multiply(matrix, rotateMatrix, matrix);
            // mat4.multiply(matrix, scaleMatrix, matrix);
            // mat4.multiply(matrix, translateMatrix, matrix);
            // mat4.multiply(matrix, projectionMatrix, matrix);
        }else if(type===Scene.changeOrigin){

            //可理解为改变了原点 此时原点(100,100)
            //mat4.multiply(matrix, matrix, translateMatrix);

            //todo requestAnimationFrame
            var Render = {
                angle: 2
            };
            function renderLoop(){
                var rotateMatrix = mat4.fromRotation(mat4.create(), (++Render.angle)*Math.PI/180, vec3.fromValues(0,1,0));
                var matrix = mat4.create();
                //todo 改变原点
                // 执行顺序:T R S T P I (反向执行是相对原点)
                mat4.multiply(matrix, matrix, projectionMatrix);
                mat4.multiply(matrix, matrix, translateMatrix);
                mat4.multiply(matrix, matrix, scaleMatrix);
                mat4.multiply(matrix, matrix, rotateMatrix);

                gl.uniformMatrix4fv(matrixLocation, false, matrix);
                gl.drawArrays(gl.TRIANGLES, 0, 18);
                if(Render.angle < 360){
                    requestAnimationFrame(renderLoop);
                }
            }
            renderLoop();
        }

    }

    // Fill the buffer with the values that define a letter 'F'.
    function setGeometry(gl) {
        gl.bufferData(
                gl.ARRAY_BUFFER,
                new Float32Array([
                    // left column
                    0,   0,  0,
                    30,   0,  0,
                    0, 150,  0,
                    0, 150,  0,
                    30,   0,  0,
                    30, 150,  0,

                    // top rung
                    30,   0,  0,
                    100,   0,  0,
                    30,  30,  0,
                    30,  30,  0,
                    100,   0,  0,
                    100,  30,  0,

                    // middle rung
                    30,  60,  0,
                    67,  60,  0,
                    30,  90,  0,
                    30,  90,  0,
                    67,  60,  0,
                    67,  90,  0]),
                gl.STATIC_DRAW);
    }
</script>
</body>
</html>